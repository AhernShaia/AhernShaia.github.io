<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker 概述</title>
    <url>/2023/04/01/docker/1-Docker%20%E6%A6%82%E8%BF%B0%20/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h1 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h1><ul>
<li><p>上線流程繁瑣</p>
<p>  開發 → 測試 → 申請資源 → 審批 → 部署 → 測試…等環節</p>
</li>
<li><p>資源利用率低</p>
<p>  普遍服務器利用率低,造成過多浪費</p>
</li>
<li><p>擴容&#x2F;縮容不及時</p>
<p>  業務高峰期擴容流程繁瑣,上線不及時</p>
</li>
<li><p>服務氣環境臃腫</p>
<p>  服務器臃腫,對後期維護、遷移造成諸多不便</p>
</li>
<li><p>環境不一致</p>
</li>
</ul>
<hr>
<h1 id="What"><a href="#What" class="headerlink" title="What?"></a>What?</h1><ul>
<li>操作系統級的虛擬化技術</li>
<li>依賴linux特性: Namespace(資源隔離), Cgroups(資源限制)</li>
<li>簡單的應用程式打包工具</li>
</ul>
<hr>
<h1 id="容器VS虛擬化"><a href="#容器VS虛擬化" class="headerlink" title="容器VS虛擬化"></a>容器VS虛擬化</h1><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ol>
<li>容器提供一個獨立的環境,實踐環境隔離、資源限制</li>
<li>主要解決應用層問題,便於快速部署、高效管理</li>
</ol>
<h3 id="虛擬化"><a href="#虛擬化" class="headerlink" title="虛擬化"></a>虛擬化</h3><ol>
<li>提供服務器資源利用率</li>
<li>完全隔離的環境</li>
</ol>
<h1 id="安裝Docker"><a href="#安裝Docker" class="headerlink" title="安裝Docker"></a>安裝Docker</h1><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加Docker yum源</span><br>yum-config-manager \<br>--add-repo \<br>https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#安裝依賴包</span><br>yum install -y yum-utils<br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#安裝DockerCE</span><br>yum install docker-ce docker-ce-cli containerd.io -y<br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#啟動Docker服務並設置開機啟動</span><br>systemctl start docker<br>systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 鏡像管理</title>
    <url>/2023/04/01/docker/2-Docker%20%E9%8F%A1%E5%83%8F%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h1 id="Docker-鏡像管理"><a href="#Docker-鏡像管理" class="headerlink" title="Docker 鏡像管理"></a>Docker 鏡像管理</h1><h1 id="鏡像"><a href="#鏡像" class="headerlink" title="鏡像"></a>鏡像</h1><ul>
<li>分層存儲的文件</li>
<li>軟體應用的環境</li>
<li>單一鏡像可創建多個容器(相當於模板)</li>
<li>不需依賴Linux內核而又精簡的Linux操作系統</li>
</ul>
<hr>
<h1 id="鏡像與容器"><a href="#鏡像與容器" class="headerlink" title="鏡像與容器"></a>鏡像與容器</h1><ul>
<li>鏡像 類似於虛擬機鏡像,一個只<strong>讀</strong>模板</li>
<li>容器 通過鏡像創建的實例</li>
</ul>
<p><img src="/img/docker/2-%E9%8F%A1%E5%83%8F%E7%AE%A1%E7%90%86/Untitled.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看docker </span><br>docker info<br><br>Server Version: 20.10.9  <span class="hljs-comment">#目前版本</span><br>Storage Driver: overlay2 <span class="hljs-comment">#存儲驅動 (image的存放位置: var/lib/docker/驅動目錄)</span><br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#拉取鏡像</span><br>docker pull <span class="hljs-string">&quot;image:tag&quot;</span><br><span class="hljs-comment">#查看鏡像</span><br>docker images<br><span class="hljs-comment">#創建容器,運行</span><br>docker run -d --name <span class="hljs-string">&quot;自定義名稱&quot;</span> <span class="hljs-string">&quot;鏡像名&quot;</span><br><span class="hljs-comment">#查看容器</span><br>docker ps<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><table>
<thead>
<tr>
<th>docker</th>
<th>image &lt;命令&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>命令</td>
<td>描述</td>
</tr>
<tr>
<td>ls</td>
<td>列出鏡像</td>
</tr>
<tr>
<td>build</td>
<td>建構鏡像(Dockerfile)</td>
</tr>
<tr>
<td>history</td>
<td>查看鏡像歷史</td>
</tr>
<tr>
<td>inspect</td>
<td>顯示鏡像詳細訊息</td>
</tr>
<tr>
<td>pull</td>
<td>從鏡像倉庫拉取鏡像</td>
</tr>
<tr>
<td>push</td>
<td>推送一個鏡像到鏡像倉庫</td>
</tr>
<tr>
<td>rm</td>
<td>刪除鏡像</td>
</tr>
<tr>
<td>prune</td>
<td>移除沒有被標記或著沒有被容器引用的鏡像</td>
</tr>
<tr>
<td>tag</td>
<td>創建一個引用源鏡像,標記鏡像</td>
</tr>
<tr>
<td>export</td>
<td>導出容器文件系統到tar歸檔文件</td>
</tr>
<tr>
<td>import</td>
<td>導入容器文件系統tar歸檔文件創建鏡像</td>
</tr>
<tr>
<td>save</td>
<td>保存一個或多個鏡像到一個tar歸檔文件</td>
</tr>
<tr>
<td>load</td>
<td>加載鏡像來自tar歸檔或標準輸入</td>
</tr>
</tbody></table>
<h1 id="鏡像存儲-聯合文件系統-UnionFS"><a href="#鏡像存儲-聯合文件系統-UnionFS" class="headerlink" title="鏡像存儲:聯合文件系統(UnionFS)"></a>鏡像存儲:聯合文件系統(UnionFS)</h1><p>相較於虛擬機一個環境裡獨立的鏡像文件,docker則引用聯合文件系統,將多層文件聯合掛載到一個容器文件系統。</p>
<hr>
<p><img src="/img/docker/2-%E9%8F%A1%E5%83%8F%E7%AE%A1%E7%90%86/Untitled%201.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<hr>
<h1 id="鏡像存儲-寫時複製"><a href="#鏡像存儲-寫時複製" class="headerlink" title="鏡像存儲:寫時複製"></a>鏡像存儲:寫時複製</h1><p>鏡像只供讀取,以共享的形式供多個容器使用,如果需要在容器修改文件(即鏡像裡的文件),docker引用了寫時複製(copy on write),將鏡像裡的文件複製到容器的文件系統進行修改。</p>
<p><img src="/img/docker/2-%E9%8F%A1%E5%83%8F%E7%AE%A1%E7%90%86/Untitled%202.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 容器管理</title>
    <url>/2023/04/01/docker/3-%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="創建容器常用選項"><a href="#創建容器常用選項" class="headerlink" title="創建容器常用選項"></a>創建容器常用選項</h1><table>
<thead>
<tr>
<th>選項</th>
<th align="left">說明</th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td>i, –interactive</td>
<td align="left">交互式</td>
<td align="left"></td>
</tr>
<tr>
<td>-t, –tty</td>
<td align="left">分配一個偽裝端</td>
<td align="left"></td>
</tr>
<tr>
<td>-d, –detach</td>
<td align="left">在後台運行</td>
<td align="left"></td>
</tr>
<tr>
<td>-e, –env</td>
<td align="left">設定環境變量</td>
<td align="left">可設置多個環境變量(-e)</td>
</tr>
<tr>
<td>-p, –publish list</td>
<td align="left">發佈容器端口到主機(暴露端口)</td>
<td align="left">“自定義端口”:”服務端口”(ex: -p 9999:80)</td>
</tr>
<tr>
<td>-P, -publish-all</td>
<td align="left">發佈容器所有EXPOSE的端口到宿主機隨機端口</td>
<td align="left"></td>
</tr>
<tr>
<td>–-name string</td>
<td align="left">指定容器名稱</td>
<td align="left"></td>
</tr>
<tr>
<td>-h, –hostname</td>
<td align="left">設置容器主機名</td>
<td align="left"></td>
</tr>
<tr>
<td>–ip,string</td>
<td align="left">指定容器IP,可用於自定義網路</td>
<td align="left"></td>
</tr>
<tr>
<td>–network</td>
<td align="left">連接容器到一個網路</td>
<td align="left"></td>
</tr>
<tr>
<td>–mount mount</td>
<td align="left">將文件系統附加到容器</td>
<td align="left"></td>
</tr>
<tr>
<td>-v, –volume list</td>
<td align="left">綁定掛載一個卷</td>
<td align="left"></td>
</tr>
<tr>
<td>–restart stringload</td>
<td align="left">容器退出時重啟策略,預設為no,可選值</td>
<td align="left"></td>
</tr>
</tbody></table>
<hr>
<h1 id="資源限制"><a href="#資源限制" class="headerlink" title="資源限制"></a>資源限制</h1><ul>
<li>創建的容器預設使用宿主機所有資源</li>
</ul>
<table>
<thead>
<tr>
<th>選項</th>
<th>描述</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>-m, -memory</td>
<td>限制容器記憶體</td>
<td></td>
</tr>
<tr>
<td>-memory-swap</td>
<td>允許交換到磁盤空間的記憶體</td>
<td></td>
</tr>
<tr>
<td>-memory-swappiness&#x3D;&lt;0-100&gt;</td>
<td>容器使用swap分區交換的百分比</td>
<td></td>
</tr>
<tr>
<td>-oom-kill-disable</td>
<td>禁用OOM Killer</td>
<td>當機器的物理記憶體不足時,Linux會找出占用資源最大的服務並殺死</td>
</tr>
<tr>
<td>pull</td>
<td>從鏡像倉庫拉取鏡像</td>
<td></td>
</tr>
<tr>
<td>push</td>
<td>推送一個鏡像到鏡像倉庫</td>
<td></td>
</tr>
<tr>
<td>rm</td>
<td>刪除鏡像</td>
<td></td>
</tr>
<tr>
<td>prune</td>
<td>移除沒有被標記或著沒有被容器引用的鏡像</td>
<td></td>
</tr>
<tr>
<td>tag</td>
<td>創建一個引用源鏡像,標記鏡像</td>
<td></td>
</tr>
<tr>
<td>export</td>
<td>導出容器文件系統到tar歸檔文件</td>
<td></td>
</tr>
<tr>
<td>import</td>
<td>導入容器文件系統tar歸檔文件創建鏡像</td>
<td></td>
</tr>
<tr>
<td>save</td>
<td>保存一個或多個鏡像到一個tar歸檔文件</td>
<td></td>
</tr>
<tr>
<td>load</td>
<td>加載鏡像來自tar歸檔或標準輸入</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h1 id="隔離性-Namespace"><a href="#隔離性-Namespace" class="headerlink" title="隔離性(Namespace)"></a>隔離性(Namespace)</h1><p>在物理機器中可以運行多個不同的操作系統,這就需要解決隔離性的問題,將環境單獨分開,相互不影響。</p>
<p>Linux kernel在2.4.19版本開始,引用了namespace概念,目的是將特定的全局資源通過抽象方法使namespace中的進程看起來擁有自己隔離的資源。docker就是透過這個機制實現容器資源隔離。</p>
<h2 id="Linux的Namespace機制提供了6種不同命名空間："><a href="#Linux的Namespace機制提供了6種不同命名空間：" class="headerlink" title="Linux的Namespace機制提供了6種不同命名空間："></a>Linux的Namespace機制提供了6種不同命名空間：</h2><ul>
<li><strong>IPC</strong>：隔離進程間通信</li>
<li><strong>MOUNT</strong>：隔離文件系統掛載點</li>
<li><strong>NET</strong>：隔離網絡協議棧</li>
<li><strong>PID</strong>：隔離進程號，進程命名空間是一個父子結構，子空間對父空間可見</li>
<li><strong>USER</strong>：隔離用戶</li>
<li><strong>UTS</strong>：隔離主機名和域名</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">ll /proc/$$/ns<br></code></pre></td></tr></table></figure>

<p><img src="/img/docker/3-%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/Untitled.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<hr>
<h1 id="CGroup"><a href="#CGroup" class="headerlink" title="CGroup"></a>CGroup</h1><p>Docker利用namespace實現了容器間的資源隔離,但是無法對容器進行資源限制,如CPU、memory。</p>
<p>當一個容器屬於CPU密集性的服務,這時就會占用大量的CPU,進而導致其他容器相互影響,搶占資源。</p>
<p>所有的任務就是運行在系統中的一個進程，而 <strong>CGroups</strong> 以某種標準將一組進程為目標進行資源分配和控制。例如CPU、memory、網路等，並且可以<strong>動態配置</strong>。</p>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ol>
<li>限制進程組使用的資源數量（ Resource limitation ）：可以為進程組設定資源使用上限，例如memory。</li>
<li>進程組優先級控制（ Prioritization ）：可以為進程組分配特定CPU、磁盤IO吞吐量</li>
<li>記錄進程組使用的資源數量（ Accounting ）：例如使用記錄某個進程組使用的CPU時間</li>
<li>進程組控制（ Control ）：可以將進程組掛起和恢復</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看cgroups可控制的資源：</span><br><span class="hljs-built_in">ls</span> /sys/fs/cgroup/ -l <br>docker update --<span class="hljs-built_in">help</span> <span class="hljs-comment">#可查看相關指令</span><br></code></pre></td></tr></table></figure>

<p><img src="/img/docker/3-%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/Untitled%201.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<blockquote>
<p>blkio ：對塊設備的IO進行限制。<br>cpu：限制CPU時間片的分配，與cpuacct掛載同一層目錄。<br>cpuacct ：生成cgroup中的任務佔用CPU資源的報告，與cpu掛載同一目錄。<br>cpuset ：給cgroup中的任務分配獨立的CPU（多核處理器）和memory節點。<br>devices ：允許或著拒絕 cgroup 中的任務訪問設備。<br>freezer ：暫停&#x2F;恢復 cgroup 中的任務。<br>hugetlb ：限制使用的memory頁數量。<br>memory ：對cgroup 中任務的可用memory進行限制，並自動生成資源佔用報告。<br>net_cls ：使用等級識別符（classid）標記網絡數據包，這讓 Linux 流量控製程序（tc）可以識別來自   特定從cgroup 任務的數據包，並進行網絡限制。<br>net_prio：允許基於cgroup設置網絡流量的優先級。<br>perf_event：允許使用perf工具來監控cgroup。<br>pids：限制任務的數量。</p>
</blockquote>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 容器數據持久化</title>
    <url>/2023/04/02/docker/4-%E5%AE%B9%E5%99%A8%E6%95%B8%E6%93%9A%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h3 id="當容器刪除時-容器內的數據也會被刪除-如果需要保留數據的話就需要將數據掛載到本地。"><a href="#當容器刪除時-容器內的數據也會被刪除-如果需要保留數據的話就需要將數據掛載到本地。" class="headerlink" title="當容器刪除時,容器內的數據也會被刪除,如果需要保留數據的話就需要將數據掛載到本地。"></a>當容器刪除時,容器內的數據也會被刪除,如果需要保留數據的話就需要將數據掛載到本地。</h3><h2 id="Docker提供以下三種方式將數據從宿主機掛載到容器中"><a href="#Docker提供以下三種方式將數據從宿主機掛載到容器中" class="headerlink" title="Docker提供以下三種方式將數據從宿主機掛載到容器中:"></a>Docker提供以下三種方式將數據從宿主機掛載到容器中:</h2><p><img src="/img/docker/4-%E5%AE%B9%E5%99%A8%E6%95%B8%E6%93%9A%E6%8C%81%E4%B9%85%E5%8C%96/Untitled.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<ul>
<li><strong>volume</strong> : Docker管理宿主機文件系統的一部分( &#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes)。<ul>
<li>應用場景：<ul>
<li>多個運行容器間共享數據</li>
<li>當Docker主機不確保具有給定的目錄或文件時。卷可以將容器運行時與Docker主機的配置解耦合</li>
<li>備份、恢復、或將數據從一個Docker主機遷移到另一個Docker主機時</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#創建容器建立volume</span><br>docker volume create<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>bind mounts</strong> : 將宿主機上任意位置的文件或目錄引用到容器中，在使用綁定掛載時，這些目錄或文件不一定要存在，可掛載多個目錄。<ul>
<li>應用場景：<ul>
<li>主機與容器共享文件（Docker預設情況下通過這種方式為容器提供DNS解析，通過將&#x2F;etc&#x2F;resolv.conf掛載到容器中）</li>
<li>共享源程式或build artifacts（比如將Maven的target&#x2F;目錄掛載到容器中，每次在Docker主機中build Maven時，容器能夠訪問到那些rebuilt artifacts）</li>
<li>當docker主機中的文件或目錄結構和容器需要的一致時</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker run -d -it --name devtest --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=<span class="hljs-string">&quot;<span class="hljs-subst">$(pwd)</span>&quot;</span>/target,target=/app --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=<span class="hljs-string">&quot;<span class="hljs-subst">$(pwd)</span>&quot;</span>/target,target=/app2,<span class="hljs-built_in">readonly</span>,bind-propagation=rslave    nginx:latest<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>tmpfs</strong> : 掛載存儲在主機系統的內存中，而不會寫入主機的文件系統。如果不希望將數據持久存儲在任何位置，可以使用tmpfs，同時避免寫入容器可寫層提高性能<ul>
<li>應用場景：<ul>
<li>最好的使用場景是既不想將數據存於主機，又不想存於容器中時。這可以是出於安全的考慮，或當應用需要寫大量非持久性的狀態數據時為了保護容器的性能</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Harbor</title>
    <url>/2023/04/02/docker/harbor/</url>
    <content><![CDATA[<hr>
<span id="more"></span>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h1><p>是由VMWare開源的容器鏡像倉庫,基於<strong>Docker registry</strong>做的擴展。</p>
<p>配置需求:</p>
<ul>
<li>CPU 2核&#x2F;記憶體4G&#x2F;硬碟空間40GB</li>
<li>建議配置: 4核&#x2F;記憶體8G&#x2F;硬碟空間160GB</li>
<li>Docker CE 17.06 以上</li>
<li>Docker Compose 1.18 以上</li>
</ul>
<p>安裝方式:</p>
<blockquote>
<p>Docker Hub下載Harbor相關鏡像。</p>
</blockquote>
<blockquote>
<p>安裝包,包含相關部署鏡像,佔用空間較大。</p>
</blockquote>
<hr>
<h1 id="部署HTTP"><a href="#部署HTTP" class="headerlink" title="部署HTTP"></a>部署HTTP</h1><h2 id="1、安裝Docker和Docker-Compose"><a href="#1、安裝Docker和Docker-Compose" class="headerlink" title="1、安裝Docker和Docker Compose"></a>1、安裝Docker和Docker Compose</h2><h3 id="下載docker-compose並安裝"><a href="#下載docker-compose並安裝" class="headerlink" title="下載docker-compose並安裝"></a>下載docker-compose並安裝</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># docker-compose</span><br>wget https://github.com/docker/compose/releases/download/v2.0.1/docker-compose-linux-x86_64<br><span class="hljs-built_in">mv</span> docker-compose-linux-x86_64 /usr/bin/docker-compose<br><span class="hljs-built_in">chmod</span> +x /usr/bin/docker-compose<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="2、下載harbor安裝、啟用"><a href="#2、下載harbor安裝、啟用" class="headerlink" title="2、下載harbor安裝、啟用"></a>2、下載harbor安裝、啟用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># harbor</span><br>wget https://github.com/goharbor/harbor/releases/download/v2.2.2-rc1/harbor-offline-installer-v2.2.2-rc1.tgz<br>tar zxvf harbor-offline-installer-v2.2.2-rc1.tgz<br><br><span class="hljs-comment"># 修改 harbor.yml文件</span><br>hostname: **reg.ahern.com**  <span class="hljs-comment"># 訪問域名</span><br>Harbor12345<br><br><span class="hljs-comment"># 執行準備腳本</span><br>./prepare<br><span class="hljs-comment"># 執行安裝腳本</span><br>./instal.sh<br><br><span class="hljs-comment"># 綁定host</span><br>vi /etc/hosts<br>主機IP **reg.ahern.com**<br><br></code></pre></td></tr></table></figure>

<p><img src="/img/docker/harbor/Untitled.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<h3 id="登入harbor"><a href="#登入harbor" class="headerlink" title="登入harbor"></a>登入harbor</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#配置鏡像倉庫可信任</span><br>vi /etc/docker/daemon.json<br>&#123;<span class="hljs-string">&quot;insecure-registries&quot;</span>:[<span class="hljs-string">&quot;reg.ctnrs.com&quot;</span>]&#125;<br><br><span class="hljs-comment"># 重啟</span><br>systemctl restart docker<br>docker-compose up -d<br><br><span class="hljs-comment"># 登入</span><br>docker login **reg.ahern.com**<br></code></pre></td></tr></table></figure>

<aside>
⚠️ 登入成功

</aside>

<p><img src="/img/docker/harbor/Untitled%201.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<h3 id="推送鏡像"><a href="#推送鏡像" class="headerlink" title="推送鏡像"></a>推送鏡像</h3><p>點選 <strong>項目名</strong> → <strong>推送鏡像的Docker命令 可查看推送命令</strong></p>
<p><img src="/img/docker/harbor/Untitled%202.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p><img src="/img/docker/harbor/Untitled%203.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<h1 id="部署HTTPS"><a href="#部署HTTPS" class="headerlink" title="部署HTTPS"></a>部署HTTPS</h1><ol>
<li><p>生成SSL證書</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 獲取cfssl文件</span><br>wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64<br>wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64<br>wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64<br><span class="hljs-built_in">chmod</span> +x cfssl*<br><span class="hljs-built_in">mv</span> cfssl_linux-amd64 /usr/bin/cfssl<br><span class="hljs-built_in">mv</span> cfssljson_linux-amd64 /usr/bin/cfssljson<br><span class="hljs-built_in">mv</span> cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo<br></code></pre></td></tr></table></figure>
 <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成ca設定文件</span><br><span class="hljs-built_in">cat</span> &gt; ca-config.json &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;signing&quot;: &#123;</span><br><span class="hljs-string">    &quot;default&quot;: &#123;</span><br><span class="hljs-string">      &quot;expiry&quot;: &quot;87600h&quot;</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &quot;profiles&quot;: &#123;</span><br><span class="hljs-string">      &quot;kubernetes&quot;: &#123;</span><br><span class="hljs-string">         &quot;expiry&quot;: &quot;87600h&quot;,</span><br><span class="hljs-string">         &quot;usages&quot;: [</span><br><span class="hljs-string">            &quot;signing&quot;,</span><br><span class="hljs-string">            &quot;key encipherment&quot;,</span><br><span class="hljs-string">            &quot;server auth&quot;,</span><br><span class="hljs-string">            &quot;client auth&quot;</span><br><span class="hljs-string">        ]</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-built_in">cat</span> &gt; ca-csr.json &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    &quot;CN&quot;: &quot;kubernetes&quot;,</span><br><span class="hljs-string">    &quot;key&quot;: &#123;</span><br><span class="hljs-string">        &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="hljs-string">        &quot;size&quot;: 2048</span><br><span class="hljs-string">    &#125;,</span><br><span class="hljs-string">    &quot;names&quot;: [</span><br><span class="hljs-string">        &#123;</span><br><span class="hljs-string">            &quot;C&quot;: &quot;CN&quot;,</span><br><span class="hljs-string">            &quot;L&quot;: &quot;Beijing&quot;,</span><br><span class="hljs-string">            &quot;ST&quot;: &quot;Beijing&quot;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    ]</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">EOF</span><br><span class="hljs-comment"># 生成文件</span><br>cfssl gencert -initca ca-csr.json | cfssljson -bare ca -<br><br><span class="hljs-built_in">cat</span> &gt; reg.ctnrs.com-csr.json &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;CN&quot;: &quot;**reg.ahern.com**&quot;,</span><br><span class="hljs-string">  &quot;hosts&quot;: [],</span><br><span class="hljs-string">  &quot;key&quot;: &#123;</span><br><span class="hljs-string">    &quot;algo&quot;: &quot;rsa&quot;,</span><br><span class="hljs-string">    &quot;size&quot;: 2048</span><br><span class="hljs-string">  &#125;,</span><br><span class="hljs-string">  &quot;names&quot;: [</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;C&quot;: &quot;CN&quot;,</span><br><span class="hljs-string">      &quot;L&quot;: &quot;BeiJing&quot;,</span><br><span class="hljs-string">      &quot;ST&quot;: &quot;BeiJing&quot;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  ]</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">EOF</span><br><span class="hljs-comment"># 生成證書</span><br>cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=kubernetes reg.ctnrs.com-csr.json | cfssljson -bare reg.ctnrs.com<br></code></pre></td></tr></table></figure>
</li>
<li><p>Harbor啟用HTTPS</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vi harbor.yml<br><br><span class="hljs-comment">#修改以下配置</span><br>https:<br>port: 443<br>certificate: /root/harbor/ssl/**reg.ahern.com.pem**<br>private_key: /root/harbor/ssl/**reg.ahern.com-key.pem**<br></code></pre></td></tr></table></figure>
</li>
<li><p>重新配置、部署Harbor</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#更新配置</span><br>./prepare<br><br>docker-compose down<br>docker-compose up –d<br></code></pre></td></tr></table></figure>
<p> <img src="/img/docker/harbor/Untitled%204.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
 <aside>
 ⚠️ 查看憑證是我們生成的證書
 
<p> <img src="/img/docker/harbor/Untitled%205.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
 </aside></li>
</ol>
<h3 id="客戶端訪問配置"><a href="#客戶端訪問配置" class="headerlink" title="客戶端訪問配置"></a>客戶端訪問配置</h3><p>從其他主機 docker login登入至服務端的harbor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#綁定服務端的hosts</span><br>vi /etc/hosts<br><br></code></pre></td></tr></table></figure>

<aside>
‼️ 由于harbor未配置https，需要在docker配置可信任。

</aside>

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># cat /etc/docker/daemon.json </span><br>&#123;<span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;**https://b9pmyelo.mirror.aliyuncs.com**&quot;</span>],<br>  <span class="hljs-string">&quot;insecure-registries&quot;</span>: [<span class="hljs-string">&quot;**192.168.31.130**&quot;</span>]<br>&#125;<br><span class="hljs-comment"># systemctl restart docker</span><br></code></pre></td></tr></table></figure>

<aside>
⚠️ 證書簽名問題

</aside>

<p><img src="/img/docker/harbor/Untitled%206.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>將證書複製到客戶端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">scp **reg.ahern.com.pem root@192.168.238.131**:~<br><br><span class="hljs-comment">#創建證書目錄(docker預設)</span><br><span class="hljs-built_in">mkdir</span> /etc/docker/certs.d/**reg.ahern.com**<br><br><span class="hljs-comment">#將證書放到該目錄下並改成 crt後綴</span><br><span class="hljs-built_in">cp</span> **reg.ahern.com.** /etc/docker/certs.d/**reg.ahern.com.crt**<br></code></pre></td></tr></table></figure>

<p>複製拉取鏡像命令</p>
<p><img src="/img/docker/harbor/Untitled%207.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<aside>
⚠️ 客戶端成功拉取到鏡像

</aside>

<p><img src="/img/docker/harbor/Untitled%208.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p><img src="/img/docker/harbor/Untitled%209.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<hr>
<h1 id="主從複製"><a href="#主從複製" class="headerlink" title="主從複製"></a>主從複製</h1><p>目的是解決高可用問題</p>
<ul>
<li><p><strong>主備</strong></p>
<p>  簡易,主掛了之後會切會備用Harbor</p>
<p>  同時只提供一台服務</p>
<p>  適合少量鏡像傳輸</p>
</li>
</ul>
<p><img src="/img/docker/harbor/Untitled%2010.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<ul>
<li><p>雙主複製</p>
<p>  雙向配置複製</p>
<p>  同時兩台服務運行</p>
<p>  需要負載均衡</p>
</li>
</ul>
<p><img src="/img/docker/harbor/Untitled%2011.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<ul>
<li><p>一主多從</p>
<p>  多個從同步主配置</p>
<p>  適合多區域業務(跨機房),大量鏡像傳輸需求</p>
</li>
</ul>
<p><img src="/img/docker/harbor/Untitled%2012.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<h1 id="主備環境搭建"><a href="#主備環境搭建" class="headerlink" title="主備環境搭建"></a>主備環境搭建</h1><ul>
<li>兩台虛擬機: 1 台主服務 、1 台客戶端</li>
<li>harbor</li>
<li>docker-compose</li>
</ul>
<h2 id="主節點"><a href="#主節點" class="headerlink" title="主節點"></a>主節點</h2><p>倉庫管理 → 新建目標 → 填選目標機訊息</p>
<p><img src="/img/docker/harbor/Untitled%2013.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<aside>
⚠️ 連接成功

</aside>

<p><img src="/img/docker/harbor/Untitled%2014.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>複製管理 → 新建規則 → 填選目標機訊息</p>
<p><img src="/img/docker/harbor/Untitled%2015.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<aside>
⚠️ 創建成功

</aside>

<p><img src="/img/docker/harbor/Untitled%2016.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<h2 id="備用節點-—-測試鏡像管理同步"><a href="#備用節點-—-測試鏡像管理同步" class="headerlink" title="備用節點 — 測試鏡像管理同步"></a>備用節點 — 測試鏡像管理同步</h2><ol>
<li><p>鏡像打上標籤</p>
 <figure class="highlight docker"><table><tr><td class="code"><pre><code class="hljs docker">docker tag **centos reg.ahern.com/library/centos**<br></code></pre></td></tr></table></figure>
</li>
<li><p>推送鏡像</p>
 <figure class="highlight docker"><table><tr><td class="code"><pre><code class="hljs docker">docker push<br></code></pre></td></tr></table></figure>
 <aside>
 ⚠️ 推送成功
 
 </aside>
 
<p> <img src="/img/docker/harbor/Untitled%2017.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
<li><p>查看主節點 Harbo 項目 → 鏡像倉庫,已成功同步</p>
<p> <img src="/img/docker/harbor/Untitled%2018.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
</li>
</ol>
<p>harbor的容器組件</p>
<p><img src="/img/docker/harbor/Untitled%2019.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p><a href="https://www.notion.so/065fab38f6494f6bbfcbd9b70e0c1feb">harbor容器群集</a></p>
<p><img src="/img/docker/harbor/Untitled%2020.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>容器數據持久化目錄：&#x2F;data<br>日誌文件目錄：&#x2F;var&#x2F;log&#x2F;harbor</p>
<hr>
<p><a href="https://www.notion.so/Prometheus-Grafana-Docker-56a5aa6ab0854dbdb518af309cf03ea5">監控系統部署(Prometheus+Grafana監控Docker主機)</a></p>
<p><a href="https://www.notion.so/CI-aec2bf6766834052aae15d8351713851">CI 平台 容器化部署</a></p>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 容器網路</title>
    <url>/2023/04/02/docker/5-%E5%AE%B9%E5%99%A8%E7%B6%B2%E8%B7%AF/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="1-網路模式"><a href="#1-網路模式" class="headerlink" title="1.網路模式"></a>1.網路模式</h2><ul>
<li><p><strong>bridge</strong></p>
<p>  -net&#x3D;bridge</p>
<p>  預設模式,Docker啟動後創建一個 docker0網口,新創建的容器預設也是添加在這個網口。</p>
<p>  也可以自定義網路,相比預設的內部DNS發現,可以通過容器名相互通信。</p>
</li>
<li><p><strong>host</strong></p>
<p>  -net&#x3D;host</p>
<p>  容器在創建時不會有獨立的network namespace,而是和宿主機共用。配置後,只有網路和宿主機共享,其他都是隔離。</p>
</li>
<li><p><strong>none</strong></p>
<p>  -net&#x3D;none</p>
<p>  獲取獨立的network namespace,但不為容器進行網路配置,需要手動配置。</p>
</li>
<li><p><strong>container</strong></p>
<p>  -net&#x3D;container:Name&#x2F;ID</p>
<p>  與指定的容器共用一個network namespace,具有相同網路配置,兩個容器除網路外,其他都是隔離。</p>
</li>
</ul>
<h2 id="2-Docker網路模型"><a href="#2-Docker網路模型" class="headerlink" title="2.Docker網路模型"></a>2.Docker網路模型</h2><p><strong>veth pair</strong>: 成對出現的虛擬網路設備,數據從一端進,一端出,主要用於解決網路命名空間之間的隔離。</p>
<p><strong>docker0</strong>:bridge是一個二層網路設備,通過bridge可以將Linux支援的不同的端口連接起來,實現類似交換機多對多的通信。</p>
<p><img src="/img/docker/5-%E5%AE%B9%E5%99%A8%E7%B6%B2%E8%B7%AF/Untitled.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<h2 id="3-容器網路訪問原理"><a href="#3-容器網路訪問原理" class="headerlink" title="3.容器網路訪問原理"></a>3.容器網路訪問原理</h2><p><img src="/img/docker/5-%E5%AE%B9%E5%99%A8%E7%B6%B2%E8%B7%AF/Untitled%201.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<h2 id="4-容器網路核心-iptables"><a href="#4-容器網路核心-iptables" class="headerlink" title="4.容器網路核心:iptables"></a>4.容器網路核心:iptables</h2><p><img src="/img/docker/5-%E5%AE%B9%E5%99%A8%E7%B6%B2%E8%B7%AF/Untitled%202.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p><img src="/img/docker/5-%E5%AE%B9%E5%99%A8%E7%B6%B2%E8%B7%AF/Untitled%203.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p><strong>INPUT鏈</strong>：接收的數據包是本機(入站)時，應用此鏈中的規則。</p>
<p><strong>OUTPUT鏈</strong>：本機向外發送數據包(出站)時，應用此鏈中的規則。</p>
<p><strong>FORWARD鏈</strong>：需要通過防火牆中轉發送給其他地址的數據包(轉發)時，應用測<br>鏈中的規則。</p>
<p><strong>PREROUTING鏈</strong>：在對數據包做路由選擇之前，應用此鏈中的規則。 </p>
<p><strong>POSTROUTING鏈</strong>：在對數據包做路由選擇之後，應用此鏈中的規則。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#外部訪問容器</span><br>iptables -t nat -vnL DOCKER<br><span class="hljs-comment"># 容器訪問外部</span><br>iptables -t nat -vnL POSTROUTING<br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># DNAT 目的地址轉換，修改數據包目標IP。</span><br><span class="hljs-comment"># 外部訪問容器：</span><br>-A DOCKER ! -i docker0 -p tcp -m tcp --dport <span class="hljs-string">&#x27;埠&#x27;</span> -j DNAT --to-destination <span class="hljs-string">&#x27;容器IP&#x27;</span>:80<br><br><span class="hljs-comment"># MASQUERADE 動態源地址轉換</span><br><span class="hljs-comment"># SNAT 修改源IP為宿主機IP向外發出</span><br><span class="hljs-comment"># 數據包源IP來自172.17.0.0/16這個網段都要做源地址轉換</span><br><br><span class="hljs-comment"># 容器訪問外部</span><br>-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE<br></code></pre></td></tr></table></figure>

<h2 id="5-跨主機網路-docker主機容器通信"><a href="#5-跨主機網路-docker主機容器通信" class="headerlink" title="5.跨主機網路: docker主機容器通信"></a>5.跨主機網路: docker主機容器通信</h2><h3 id="Flannel是CoreOS維護的網路組件-在主機上運行daemon-process-負責維護本地的路由轉發-使用etcd儲存網路與容器之間的關係。"><a href="#Flannel是CoreOS維護的網路組件-在主機上運行daemon-process-負責維護本地的路由轉發-使用etcd儲存網路與容器之間的關係。" class="headerlink" title="Flannel是CoreOS維護的網路組件,在主機上運行daemon process,負責維護本地的路由轉發,使用etcd儲存網路與容器之間的關係。"></a>Flannel是CoreOS維護的網路組件,在主機上運行daemon process,負責維護本地的路由轉發,使用<strong>etcd</strong>儲存網路與容器之間的關係。</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安裝etcd</span><br>yum install etcd -y<br><br><span class="hljs-comment"># 配置</span><br>vi /etc/etcd/etcd.conf<br><br>ETCD_DATA_DIR=<span class="hljs-string">&quot;/var/lib/etcd/default.etcd&quot;</span><br>ETCD_LISTEN_CLIENT_URLS=<span class="hljs-string">&quot;http://&#x27;宿主機IP&#x27;:2379&quot;</span><br>ETCD_NAME=<span class="hljs-string">&quot;default&quot;</span><br>ETCD_ADVERTISE_CLIENT_URLS=<span class="hljs-string">&quot;http://&#x27;宿主機IP&#x27;:2379&quot;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安裝flannel</span><br>yum install flannel -y<br><br><span class="hljs-comment"># 配置</span><br>vi /etc/sysconfig/flanneld<br><br>FLANNEL_ETCD_ENDPOINTS=<span class="hljs-string">&quot;http://&#x27;宿主機IP&#x27;:2379&quot;</span><br>FLANNEL_ETCD_PREFIX=<span class="hljs-string">&quot;/atomic.io/network“</span><br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># etcd添加子網 set:配置 get:獲取</span><br>etcdctl --endpoints=<span class="hljs-string">&quot;http://192.168.31.73:2379&quot;</span> <span class="hljs-built_in">set</span> /atomic.io/network/config <span class="hljs-string">&#x27;&#123; &quot;Network&quot;: </span><br><span class="hljs-string">&quot;172.17.0.0/16&quot;, &quot;Backend&quot;: &#123;&quot;Type&quot;: &quot;vxlan&quot;&#125;&#125; &#x27;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 配置Docker使用flannel生成網路訊息</span><br>vi /usr/lib/systemd/system/docker.service<br>EnvironmentFile=/run/flannel/docker<br>ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock<br><br><span class="hljs-comment">#驗證</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$DOCKER_NETWORK_OPTIONS</span><br><br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#啟動服務設定開機啟動</span><br>systemctl daemon-reload<br>systemctl start flanneld<br>systemctl <span class="hljs-built_in">enable</span> flanneld<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>CI 平台部署</title>
    <url>/2023/04/02/docker/CI%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p>架構圖:</p>
<p><img src="/img/docker/CI%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2/CICD.jpg" srcset="/img/loading.gif" lazyload alt="CICD.jpg"></p>
<ol>
<li>開發人員將code 提交到git庫</li>
<li>由Jenkins拉取git庫的code進行編譯,編譯成功後,會打包一個新的境像推送到 harbor</li>
<li>最後部署在product環境</li>
</ol>
<h2 id="1-安裝Gitlab"><a href="#1-安裝Gitlab" class="headerlink" title="1.安裝Gitlab"></a>1.安裝Gitlab</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker run -d \<br>--name gitlab \<br>-p 8443:443 \<br>-p 9999:80 \<br>-p 9998:22 \<br>-v <span class="hljs-variable">$PWD</span>/config:/etc/gitlab \<br>-v <span class="hljs-variable">$PWD</span>/logs:/var/log/gitlab \<br>-v <span class="hljs-variable">$PWD</span>/data:/var/opt/gitlab \<br>-v /etc/localtime:/etc/localtime \<br>--restart=always \<br>lizhenliang/gitlab-ce-zh:latest<br></code></pre></td></tr></table></figure>

<h2 id="2-安裝harbor"><a href="#2-安裝harbor" class="headerlink" title="2.安裝harbor"></a>2.安裝harbor</h2><h2 id="3-部署jenkins"><a href="#3-部署jenkins" class="headerlink" title="3.部署jenkins"></a>3.部署jenkins</h2><ul>
<li><p>準備JDK和Maven環境</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">tar zxvf jdk-8u45-linux-x64.tar.gz<br><span class="hljs-built_in">mv</span> jdk1.8.0_45 /usr/local/jdk<br>tar zxf apache-maven-3.5.0-bin.tar.gz<br><span class="hljs-built_in">mv</span> apache-maven-3.5.0 /usr/local/maven<br></code></pre></td></tr></table></figure>
<p>  啟動jenkins ,掛載 jdk,maven 依賴源</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker run -d --name jenkins -p 80:8080 -p 50000:50000 -u root  \<br>   -v /opt/jenkins_home:/var/jenkins_home \<br>   -v /var/run/docker.sock:/var/run/docker.sock   \<br>   -v /usr/bin/docker:/usr/bin/docker \<br>   -v /usr/local/maven:/usr/local/maven \<br>   -v /usr/local/jdk:/usr/local/jdk \<br>   -v /etc/localtime:/etc/localtime \<br>   --restart=always \<br>   --name jenkins jenkins/jenkins<br></code></pre></td></tr></table></figure>
<p>  安裝插件</p>
<p>  管理Jenkins→系统配置→管理插件→搜索git&#x2F;<strong>pipeline</strong>，點選後<strong>安裝</strong></p>
  <figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy"><span class="hljs-meta">#!/usr/bin/env groovy</span><br><br><span class="hljs-keyword">def</span> registry = <span class="hljs-string">&quot;**reg.ahern.com**&quot;</span><br># 專案名<br><span class="hljs-keyword">def</span> project = <span class="hljs-string">&quot;welcome&quot;</span><br><span class="hljs-keyword">def</span> app_name = <span class="hljs-string">&quot;demo&quot;</span><br># 鏡像地址/專案名<br><span class="hljs-keyword">def</span> image_name = <span class="hljs-string">&quot;$&#123;registry&#125;/$&#123;project&#125;/$&#123;app_name&#125;:$&#123;**Branch**&#125;-$&#123;BUILD_NUMBER&#125;&quot;</span><br><span class="hljs-keyword">def</span> git_address = <span class="hljs-string">&quot;**http://192.168.238.131:9999/root/java-demo**&quot;</span><br>#透過添加jenkins的認證訊息生成的憑證<br><span class="hljs-keyword">def</span> docker_registry_auth = <span class="hljs-string">&quot;**fdbd165a-699a-4350-af5c-78494281db15**&quot;</span><br><span class="hljs-keyword">def</span> git_auth = <span class="hljs-string">&quot;**316713bd-bbc5-47a7-8168-c3d99eddeb4c**&quot;</span><br><br>pipeline &#123;<br>    agent any<br>    stages &#123;<br>        stage(<span class="hljs-string">&#x27;拉取代码&#x27;</span>)&#123;<br>            steps &#123;<br>              checkout([<span class="hljs-attr">$class:</span> <span class="hljs-string">&#x27;GitSCM&#x27;</span>, <span class="hljs-attr">branches:</span> [[<span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;$&#123;Branch&#125;&#x27;</span>]], <span class="hljs-attr">userRemoteConfigs:</span> [[<span class="hljs-attr">credentialsId:</span> <span class="hljs-string">&quot;$&#123;git_auth&#125;&quot;</span>, <span class="hljs-attr">url:</span> <span class="hljs-string">&quot;$&#123;git_address&#125;&quot;</span>]]])<br>            &#125;<br>        &#125;<br><br>        stage(<span class="hljs-string">&#x27;代码编译&#x27;</span>)&#123;<br>           steps &#123;<br>             sh <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">                JAVA_HOME=/usr/local/jdk</span><br><span class="hljs-string">                PATH=$JAVA_HOME/bin:/usr/local/maven/bin:$PATH</span><br><span class="hljs-string">                mvn clean package -Dmaven.test.skip=true</span><br><span class="hljs-string">                &quot;&quot;&quot;</span> <br>           &#125;<br>        &#125;<br><br>        stage(<span class="hljs-string">&#x27;构建镜像&#x27;</span>)&#123;<br>           steps &#123;<br>                withCredentials([usernamePassword(<span class="hljs-attr">credentialsId:</span> <span class="hljs-string">&quot;$&#123;docker_registry_auth&#125;&quot;</span>, <span class="hljs-attr">passwordVariable:</span> <span class="hljs-string">&#x27;password&#x27;</span>, <span class="hljs-attr">usernameVariable:</span> <span class="hljs-string">&#x27;username&#x27;</span>)]) &#123;<br>                sh <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">                  echo &#x27;</span><br><span class="hljs-string">                    FROM $&#123;registry&#125;/library/tomcat:v1</span><br><span class="hljs-string">                    LABEL maitainer lizhenliang</span><br><span class="hljs-string">                    RUN rm -rf /usr/local/tomcat/webapps/*</span><br><span class="hljs-string">                    ADD target/*.war /usr/local/tomcat/webapps/ROOT.war</span><br><span class="hljs-string">                  &#x27; &gt; Dockerfile</span><br><span class="hljs-string">                  docker build -t $&#123;image_name&#125; .</span><br><span class="hljs-string">                  docker login -u $&#123;username&#125; -p &#x27;$&#123;password&#125;&#x27; $&#123;registry&#125;</span><br><span class="hljs-string">                  docker push $&#123;image_name&#125;</span><br><span class="hljs-string">                &quot;&quot;&quot;</span><br>                &#125;<br>           &#125; <br>        &#125;<br><br>        stage(<span class="hljs-string">&#x27;部署到Docker&#x27;</span>)&#123;<br>           steps &#123;<br>              sh <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">              docker rm -f tomcat-java-demo |true</span><br><span class="hljs-string">              docker container run -d --name tomcat-java-demo -p 88:8080 $&#123;image_name&#125;</span><br><span class="hljs-string">              &quot;&quot;&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>  將harbor的憑證訊息交由jenkins</p>
<p>  Jenkins → 管理Jenkins → <strong><a href="http://192.168.238.131/credentials">Manage Credentials</a> → global → 添加harbor 登入訊息</strong></p>
<p>  <img src="/img/docker/CI%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2/Untitled.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p>  添加完後生成憑證(ID)</p>
<p>  <img src="/img/docker/CI%E5%B9%B3%E5%8F%B0%E9%83%A8%E7%BD%B2/Untitled%201.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
  <aside>
  ‼️ 透過 **Pipeline Syntax** 生成相對應語法
  
  </aside></li>
</ul>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>監控系統部署(Prometheus+Grafana監控Docker主機)</title>
    <url>/2023/04/02/docker/%E7%9B%A3%E6%8E%A7%E7%B3%BB%E7%B5%B1%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述:"></a>概述:</h2><p><strong>cAdvisor</strong> : 收集正在運行的容器資源和性能等。 — <a href="https://github.com/google/cadvisor">https://github.com/google/cadvisor</a></p>
<p><strong>Prometheus</strong> : 容器監控系統。— <a href="https://prometheus.io/">https://prometheus.io/</a>   , <a href="https://github.com/prometheus">https://github.com/prometheus</a></p>
<p><strong>Grafana : 開源的度量分析和可視化系統。—</strong> <a href="https://grafana.com/grafana">https://grafana.com/grafana</a></p>
<p><strong>cAdvisor</strong> (採集所有容器資源利用率,所有docker主機部署) ←  <strong>Prometheus(收集存儲) ← Grafana(展示數據)</strong></p>
<h3 id="cAdvisor："><a href="#cAdvisor：" class="headerlink" title="cAdvisor："></a>cAdvisor：</h3><figure class="highlight docker"><table><tr><td class="code"><pre><code class="hljs docker">docker <span class="hljs-keyword">run</span><span class="language-bash"> -d \</span><br><span class="language-bash">--volume=/:/rootfs:ro \</span><br><span class="language-bash">--volume=/var/run:/var/run:ro \</span><br><span class="language-bash">--volume=/sys:/sys:ro \</span><br><span class="language-bash">--volume=/var/lib/docker/:/var/lib/docker:ro \</span><br><span class="language-bash">--volume=/dev/disk/:/dev/disk:ro \</span><br><span class="language-bash">--publish=8080:8080 \</span><br><span class="language-bash">--detach=<span class="hljs-literal">true</span> \</span><br><span class="language-bash">--name=cadvisor \</span><br><span class="language-bash">google/cadvisor:latest</span><br></code></pre></td></tr></table></figure>

<h3 id="部署Prometheus："><a href="#部署Prometheus：" class="headerlink" title="部署Prometheus："></a>部署Prometheus：</h3><figure class="highlight docker"><table><tr><td class="code"><pre><code class="hljs docker">docker <span class="hljs-keyword">run</span><span class="language-bash"> -d \</span><br><span class="language-bash">--name=prometheus \</span><br><span class="language-bash">-p 9090:9090 \</span><br><span class="language-bash">prom/prometheus</span><br></code></pre></td></tr></table></figure>

<p>修改配置文件</p>
<figure class="highlight docker"><table><tr><td class="code"><pre><code class="hljs docker">docker exec -it <span class="hljs-string">&quot;prometheus容器ID&quot;</span> sh<br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vi /etc/prometheus/prometheus.yml<br><br><span class="hljs-comment"># my global config -- 採集的周期</span><br>global:<br>  scrape_interval: 15s <span class="hljs-comment"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span><br>  evaluation_interval: 15s <span class="hljs-comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span><br>  <span class="hljs-comment"># scrape_timeout is set to the global default (10s).</span><br><br><span class="hljs-comment"># Alertmanager configuration -- 指定告警組件</span><br>alerting:<br>  alertmanagers:<br>    - static_configs:<br>        - targets:<br>          <span class="hljs-comment"># - alertmanager:9093</span><br><span class="hljs-comment"># 告警的規則</span><br><span class="hljs-comment"># Load rules once and periodically evaluate them according to the global &#x27;evaluation_interval&#x27;.</span><br>rule_files:<br>  <span class="hljs-comment"># - &quot;first_rules.yml&quot;</span><br>  <span class="hljs-comment"># - &quot;second_rules.yml&quot;</span><br><br><span class="hljs-comment"># 被採集端(目標機)的配置</span><br><span class="hljs-comment"># A scrape configuration containing exactly one endpoint to scrape:</span><br><span class="hljs-comment"># Here it&#x27;s Prometheus itself.</span><br>scrape_configs:<br>  <span class="hljs-comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span><br>  - job_name: <span class="hljs-string">&quot;prometheus&quot;</span> <span class="hljs-comment">#分組</span><br><br>    <span class="hljs-comment"># metrics_path defaults to &#x27;/metrics&#x27;</span><br>    <span class="hljs-comment"># scheme defaults to &#x27;http&#x27;.</span><br><br>    static_configs:<br>      - targets: [<span class="hljs-string">&quot;localhost:9090&quot;</span>]   <span class="hljs-comment">#監控目標</span><br></code></pre></td></tr></table></figure>

<figure class="highlight docker"><table><tr><td class="code"><pre><code class="hljs docker"><span class="hljs-comment"># 重啟</span><br>docker restart <span class="hljs-string">&quot;prometheus容器ID&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="部署Grafana："><a href="#部署Grafana：" class="headerlink" title="部署Grafana："></a>部署Grafana：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker run -d \<br>--name=grafana \<br>-p 3000:3000 \<br>grafana/grafana<br></code></pre></td></tr></table></figure>

<h3 id="加入數據源、加入prometheus地址"><a href="#加入數據源、加入prometheus地址" class="headerlink" title="加入數據源、加入prometheus地址"></a>加入數據源、加入prometheus地址</h3><p><img src="/img/docker/%E7%9B%A3%E6%8E%A7%E7%B3%BB%E7%B5%B1%E9%83%A8%E7%BD%B2/Untitled.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p><img src="/img/docker/%E7%9B%A3%E6%8E%A7%E7%B3%BB%E7%B5%B1%E9%83%A8%E7%BD%B2/Untitled%201.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p><img src="/img/docker/%E7%9B%A3%E6%8E%A7%E7%B3%BB%E7%B5%B1%E9%83%A8%E7%BD%B2/Untitled%202.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<h3 id="新增儀表盤"><a href="#新增儀表盤" class="headerlink" title="新增儀表盤"></a>新增儀表盤</h3><p><img src="/img/docker/%E7%9B%A3%E6%8E%A7%E7%B3%BB%E7%B5%B1%E9%83%A8%E7%BD%B2/Untitled%203.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<h3 id="建立篩選條件"><a href="#建立篩選條件" class="headerlink" title="建立篩選條件"></a>建立篩選條件</h3><aside>
⚠️ prometheus 使用獨有的語法做篩選, **PromQL**

</aside>

<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">container_memory_usage_bytes&#123;image!=<span class="hljs-string">&quot;&quot;</span>,name=<span class="hljs-string">&quot;cadvisor&quot;</span>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/img/docker/%E7%9B%A3%E6%8E%A7%E7%B3%BB%E7%B5%B1%E9%83%A8%E7%BD%B2/Untitled%204.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<p><img src="/img/docker/%E7%9B%A3%E6%8E%A7%E7%B3%BB%E7%B5%B1%E9%83%A8%E7%BD%B2/Untitled%205.png" srcset="/img/loading.gif" lazyload alt="Untitled"></p>
<aside>
⚠️ 圖表無數據的可能原因：

</aside>

<blockquote>
<ol>
<li>時間不同步</li>
<li>promql有問題(版本不兼容)</li>
<li>prometheus無數據</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>學習筆記</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
</search>
